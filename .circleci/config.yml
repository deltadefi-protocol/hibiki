version: 2.1
aliases:
  - &deploy_environment
    working_directory: ~/repo
    docker:
      - image: cimg/gcp:2024.08
  - &credentials_context
    context:
      - slack_creds
      - github_creds
      - gcp_creds
      - circleci_creds

orbs:
  slack: circleci/slack@4.12.5
  docker: circleci/docker@2.1.4

commands:
  clone_and_checkout_branch:
    description: "Clone and checkout the specific branch for the pipeline"
    steps:
      - add_ssh_keys # Uses all SSH keys added to the project
      - run:
          name: Clone and checkout branch
          command: |
            # Determine which branch to checkout based on PR merge status
            PR_MERGED="<< pipeline.event.github.pull_request.merged >>"

            if [ "$PR_MERGED" = "true" ]; then
              # PR is merged - checkout the base branch (target branch like develop/staging/main)
              BRANCH_NAME="<< pipeline.event.github.pull_request.base.ref >>"
              echo "âœ… PR is merged - checking out base branch: ${BRANCH_NAME}"
            else
              # PR is not merged - checkout the head branch (source/feature branch)
              BRANCH_NAME="<< pipeline.event.github.pull_request.head.ref >>"
              echo "ðŸ”¨ PR is not merged - checking out head branch: ${BRANCH_NAME}"
            fi

            SSH_REPO_URL="git@github.com:$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME.git"
            echo "Using SSH repository URL: ${SSH_REPO_URL}"

            # Configure git to use SSH and accept GitHub's host key
            mkdir -p ~/.ssh
            ssh-keyscan github.com >> ~/.ssh/known_hosts

            # Clone using SSH
            git clone "${SSH_REPO_URL}" .
            git checkout "${BRANCH_NAME}"
            echo "Successfully checked out branch: ${BRANCH_NAME}"

  detect_environment:
    description: "Detect environment based on branch (dev/staging/prod)"
    steps:
      - run:
          name: Detect environment
          command: |
            # Determine environment based on branch
            if [ "${CIRCLE_BRANCH}" = "main" ]; then
              echo "export env=prod" >> $BASH_ENV
            elif [ "${CIRCLE_BRANCH}" = "staging" ]; then
              echo "export env=staging" >> $BASH_ENV
            else
              echo "export env=dev" >> $BASH_ENV
            fi
            source $BASH_ENV
            echo "âœ… Detected environment: ${env}"

  setup_gcp_service_key:
    description: "Setup GCP service key and project ID based on environment (separate for dev/staging/prod)"
    steps:
      - run:
          name: Decode and setup GCP service key and project ID
          command: |
            # Each environment uses its own GCP service key and project ID
            if [ "${env}" = "prod" ]; then
              echo "ðŸ” Using production GCP service key and project"
              echo ${GCP_SERVICE_KEY_PROD} | base64 --decode --ignore-garbage > ${HOME}/gcloud-service-key.json
              echo "export GCLOUD_PROJECT_ID=${GCLOUD_PROJECT_ID_PROD}" >> $BASH_ENV
            elif [ "${env}" = "staging" ]; then
              echo "ðŸ” Using staging GCP service key and project"
              echo ${GCP_SERVICE_KEY_STAGING} | base64 --decode --ignore-garbage > ${HOME}/gcloud-service-key.json
              echo "export GCLOUD_PROJECT_ID=${GCLOUD_PROJECT_ID_STAGING}" >> $BASH_ENV
            else
              echo "ðŸ” Using dev GCP service key and project"
              echo ${GCP_SERVICE_KEY_DEV} | base64 --decode --ignore-garbage > ${HOME}/gcloud-service-key.json
              echo "export GCLOUD_PROJECT_ID=${GCLOUD_PROJECT_ID_DEV}" >> $BASH_ENV
            fi
            source $BASH_ENV
            echo "âœ… GCP Project ID: ${GCLOUD_PROJECT_ID}"

  setup_gcloud_cli:
    description: "Authenticate and configure gcloud CLI"
    steps:
      - run:
          name: Setup gcloud CLI
          command: |
            gcloud auth activate-service-account --key-file=${HOME}/gcloud-service-key.json
            gcloud config set project ${GCLOUD_PROJECT_ID}
            gcloud auth configure-docker asia-northeast1-docker.pkg.dev --quiet
            echo "âœ… gcloud CLI configured for project: ${GCLOUD_PROJECT_ID}"

jobs:
  build_and_push:
    <<: [*deploy_environment]
    resource_class: small
    steps:
      - clone_and_checkout_branch
      - detect_environment
      - setup_gcp_service_key
      - setup_gcloud_cli
      - setup_remote_docker:
          docker_layer_caching: true
      - run:
          name: Build and Push Docker image
          command: |
            DOCKER_IMAGE="asia-northeast1-docker.pkg.dev/$GCLOUD_PROJECT_ID/backend/$CIRCLE_PROJECT_REPONAME:$CIRCLE_SHA1"
            docker build -t $DOCKER_IMAGE --build-arg GITHUB_TOKEN=$GITHUB_TOKEN .
            docker push $DOCKER_IMAGE
      - slack/notify:
          event: fail
          template: basic_fail_1

  send_webhook:
    <<: [*deploy_environment]
    resource_class: small
    steps:
      - run:
          name: Prepare webhook payload
          command: |
            #Create the payload for the webhook
            PAYLOAD="{\"repository\":\"$CIRCLE_PROJECT_REPONAME\",\"branch\":\"$CIRCLE_BRANCH\",\"commit\":\"$CIRCLE_SHA1\"}"
            echo "export PAYLOAD='$PAYLOAD'" >> $BASH_ENV
      - run:
          name: Send webhook
          command: |
            HTTP_STATUS=$(curl -X POST -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            -w "%{http_code}" \
            -o /dev/null \
            ${WEBHOOK_URL})
            if [ "$HTTP_STATUS" -ne 200 ]; then
              echo "Webhook failed with status $HTTP_STATUS"
              exit 1
            else
              echo "Webhook sent successfully"
            fi
      - slack/notify:
          event: fail
          template: basic_fail_1
      - slack/notify:
          event: pass
          template: basic_success_1

workflows:
  # Deploy to dev when changes are pushed/merged to develop branch
  deploy_dev:
    when: pipeline.event.github.pull_request.base.ref == "develop" and pipeline.event.github.pull_request.merged == true
    jobs:
      - build_and_push:
          <<: [*credentials_context]
      - send_webhook:
          <<: [*credentials_context]
          requires:
            - build_and_push

  # Deploy to staging when changes are pushed/merged to staging branch
  deploy_staging:
    when: pipeline.event.github.pull_request.base.ref == "staging" and pipeline.event.github.pull_request.merged == true
    jobs:
      - build_and_push:
          <<: [*credentials_context]
      - send_webhook:
          <<: [*credentials_context]
          requires:
            - build_and_push

  # Deploy to prod when changes are pushed/merged to main branch (requires manual approval)
  deploy_prod:
    when: pipeline.event.github.pull_request.base.ref == "main" and pipeline.event.github.pull_request.merged == true
    jobs:
      - build_and_push:
          <<: [*credentials_context]
      - hold:
          type: approval
          context: prod_restricted_context
          requires:
            - build_and_push
      - send_webhook:
          <<: [*credentials_context]
          requires:
            - build_and_push
            - hold
